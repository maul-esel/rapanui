@GenModel(modelDirectory="rapanui.dsl/xcore-gen",complianceLevel="8.0")

package rapanui.dsl

import rapanui.dsl.Serializer
import org.eclipse.emf.ecore.util.EcoreUtil
import java.util.stream.Collectors

type StringArray wraps String[]
type Visitor wraps rapanui.dsl.Visitor

class RuleSystem {
	contains Rule[] rules
	contains Definition[] definitions

	op StringArray getDefinitionNames() {
		definitions.stream().map[ name ].collect(Collectors.toList())
	}

	op void accept(Visitor v) {
		definitions.forEach[ accept(v) ]
		rules.forEach[ accept(v) ]
		v.visit(this);
	}
}

interface PremiseContainer {
	contains Formula[] premises

	// Use a method instead of a derived feature to avoid problems with different EList
	// implementations: must return an instance of InternalEList, not BasicEList, or there
	// is a cast exception. But even with InternalEList, there's another problem where
	// the code apparently gets executed before references are resolved, which of course
	// results in NullPointerExceptions.
	// See also https://www.eclipse.org/forums/index.php?t=msg&th=552590&goto=1140023&#msg_1140023
	op Formula[] getResolvedPremises() {
		premises.map[ premise |
			if (premise instanceof DefinitionReference)
				premise.resolveToFormulas()
			else #[premise]
		].flatten.toEList
	}
}

class Rule extends PremiseContainer {
	String name
	contains Formula[] conclusions

	op void accept(Visitor v) {
		premises.forEach[ accept(v) ]
		conclusions.forEach[ accept(v) ]
	}
}
class Definition extends PremiseContainer {
	String name
	String target

	op void accept(Visitor v) {
		premises.forEach[ accept(v) ]
	}
}

abstract class Formula {
	op boolean structurallyEquals(Formula other) {
		EcoreUtil.equals(this, other)
	}

	op String serialize() {
		Serializer.getInstance().serialize(this);
	}

	op void accept(Visitor v) {
		v.visit(this)
	}
}
class Equation extends Formula {
	contains Term left
	contains Term right

	op void accept(Visitor v) {
		left.accept(v)
		right.accept(v)
		v.visit(this)
	}
}
class Inclusion extends Formula {
	contains Term left
	contains Term right

	op void accept(Visitor v) {
		left.accept(v)
		right.accept(v)
		v.visit(this)
	}
}
class DefinitionReference extends Formula {
	contains Term target
	refers Definition definition

	op void accept(Visitor v) {
		target.accept(v)
		v.visit(this)
	}

	op Formula[] resolveToFormulas() {
		val translator = new Translator(#{ definition.target -> target})
		return definition.resolvedPremises.map[ p | translator.translate(p) ]
	}
}


abstract class Term {
	op boolean structurallyEquals(Term other) {
		EcoreUtil.equals(this, other)
	}

	op String serialize() {
		Serializer.getInstance().serialize(this);
	}

	op void accept(Visitor v) {
		v.visit(this)
	}
}
class VariableReference extends Term {
	String variable

	op void accept(Visitor v) {
		v.visit(this)
	}
}
class ConstantReference extends Term {
	String constant

	op void accept(Visitor v) {
		v.visit(this)
	}
}
class UnaryOperation extends Term {
	contains Term operand
	POSTFIX_UNARY_OPERATOR operator

	op void accept(Visitor v) {
		operand.accept(v)
		v.visit(this)
	}
}
class BinaryOperation extends Term {
	contains Term left
	contains Term right
	BINARY_OPERATOR operator

	op void accept(Visitor v) {
		left.accept(v)
		right.accept(v)
		v.visit(this)
	}
}

enum POSTFIX_UNARY_OPERATOR {
	CONVERSE as '˘'
	KLEENE as '*'
	PLUS as '⁺'
	COMPLEMENT as 'ᶜ'
}
enum BINARY_OPERATOR {
	INTERSECTION as '∩'
	UNION as '∪'
	MINUS as '\\'
	COMPOSITION as ';'
}