@GenModel(modelDirectory="rapanui.dsl/xcore-gen",complianceLevel="8.0")

package rapanui.dsl

import rapanui.dsl.Serializer
import org.eclipse.emf.ecore.util.EcoreUtil
import java.util.stream.Collectors

type StringArray wraps String[]
type Visitor wraps rapanui.dsl.Visitor

class RuleSystem {
	contains Rule[] rules
	contains Definition[] definitions

	op StringArray getDefinitionNames() {
		definitions.stream().map[ name ].collect(Collectors.toList())
	}

	op void accept(Visitor v) {
		definitions.forEach[ accept(v) ]
		rules.forEach[ accept(v) ]
		v.visit(this);
	}
}

interface PremiseContainer {
	contains Predicate[] premises

	// Use a method instead of a derived feature to avoid problems with different EList
	// implementations: must return an instance of InternalEList, not BasicEList, or there
	// is a cast exception. But even with InternalEList, there's another problem where
	// the code apparently gets executed before references are resolved, which of course
	// results in NullPointerExceptions.
	// See also https://www.eclipse.org/forums/index.php?t=msg&th=552590&goto=1140023&#msg_1140023
	op Formula[] getResolvedPremises() {
		premises.map[ resolve ].flatten
			.toMap [ serialize ].values // should be unique (not by equals(), but by structure/syntax)
			.toEList
	}
}

class Rule extends PremiseContainer {
	String name
	contains Predicate[] conclusions

	op void accept(Visitor v) {
		premises.forEach[ accept(v) ]
		conclusions.forEach[ accept(v) ]
	}

	// see comments in PremiseContainer.getResolvedPremises()
	op Formula[] getResolvedConclusions() {
		conclusions.map[ resolve ].flatten
			.toMap [ serialize ].values // should be unique (not by equals(), but by structure/syntax)
			.toEList
	}
}
class Definition extends PremiseContainer {
	String name
	String target

	op void accept(Visitor v) {
		premises.forEach[ accept(v) ]
	}
}

abstract class Predicate {
	op boolean structurallyEquals(Formula other) {
		EcoreUtil.equals(this, other)
	}

	op String serialize() {
		Serializer.getInstance().serialize(this);
	}

	op void accept(Visitor v) {
		v.visit(this)
	}

	op Formula[] resolve()
}
class Formula extends Predicate {
	contains Term left
	contains Term right
	BINARY_RELATION formulaType

	op void accept(Visitor v) {
		left?.accept(v)
		right?.accept(v)
		v.visit(this)
	}

	op Formula[] resolve() {
		#[this].toEList
	}

	op boolean isTemplateFor(Formula instance) {
		(formulaType == null || formulaType == instance.formulaType)
		&& (left == null || left.isTemplateFor(instance.left))
		&& (right == null || right.isTemplateFor(instance.right))
	}
}
class DefinitionReference extends Predicate {
	contains Term target
	refers Definition definition

	op void accept(Visitor v) {
		target?.accept(v)
		v.visit(this)
	}

	op Formula[] resolve() {
		val translator = new Translator(#{ definition.target -> target})
		return definition.resolvedPremises.map[ p | translator.translate(p) ]
	}
}


abstract class Term {
	op boolean structurallyEquals(Term other) {
		EcoreUtil.equals(this, other)
	}

	op String serialize() {
		Serializer.getInstance().serialize(this);
	}

	op void accept(Visitor v) {
		v.visit(this)
	}

	op boolean isTemplateFor(Term instance)
	op boolean isComplete()
}
class VariableReference extends Term {
	String variable

	op void accept(Visitor v) {
		v.visit(this)
	}

	op boolean isTemplateFor(Term instance) {
		instance instanceof VariableReference && variable.equals((instance as VariableReference).variable)
	}

	op boolean isComplete() {
		variable != null
	}
}
class ConstantReference extends Term {
	String constant

	op void accept(Visitor v) {
		v.visit(this)
	}

	op boolean isTemplateFor(Term instance) {
		instance instanceof ConstantReference && constant.equals((instance as ConstantReference).constant)
	}

	op boolean isComplete() {
		constant != null
	}
}
class UnaryOperation extends Term {
	contains Term operand
	POSTFIX_UNARY_OPERATOR operator

	op void accept(Visitor v) {
		operand?.accept(v)
		v.visit(this)
	}

	op boolean isTemplateFor(Term instance) {
		instance instanceof UnaryOperation
		&& (operator == null || operator == (instance as UnaryOperation).operator)
		&& (operand == null || operand.isTemplateFor((instance as UnaryOperation).operand))
	}

	op boolean isComplete() {
		operator != null && operand?.isComplete()
	}
}
class BinaryOperation extends Term {
	contains Term left
	contains Term right
	BINARY_OPERATOR operator

	op void accept(Visitor v) {
		left?.accept(v)
		right?.accept(v)
		v.visit(this)
	}

	op boolean isTemplateFor(Term instance) {
		if (instance instanceof BinaryOperation)
			(operator == null || operator == instance.operator)
			&& (left == null || left.isTemplateFor(instance.left))
			&& (right == null || right.isTemplateFor(instance.right))
		else
			false
	}

	op boolean isComplete() {
		operator != null && left?.isComplete() && right?.isComplete()
	}
}

enum POSTFIX_UNARY_OPERATOR {
	CONVERSE as '˘'
	KLEENE as '*'
	PLUS as '⁺'
	COMPLEMENT as 'ᶜ'
}
enum BINARY_OPERATOR {
	INTERSECTION as '∩'
	UNION as '∪'
	MINUS as '\\'
	COMPOSITION as ';'
}
enum BINARY_RELATION {
	EQUATION as '='
	INCLUSION as '⊆'
}